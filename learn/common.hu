#include <cstdio>
#include <algorithm>

struct complex {
	__host__ __device__ complex(float re, float im = 0)
        : m_re{re}, m_im{im} {}

	float m_re, m_im;
};

inline __host__ __device__ complex operator+(const complex &a, const complex &b) {
	return complex(a.m_re + b.m_re, a.m_im + b.m_im);
}

inline __host__ __device__ complex operator-(const complex &a) {
    return complex(-a.m_re, -a.m_im);
}

inline __host__ __device__ complex operator-(const complex &a, const complex &b) {
	return complex(a.m_re - b.m_re, a.m_im - b.m_im);
}

inline __host__ __device__ complex operator*(const complex &a, const complex &b) {
	return complex(a.m_re * b.m_re - a.m_im * b.m_im, a.m_im * b.m_re + a.m_re * b.m_im);
}

inline __host__ __device__ float abs2(const complex &a) {
	return a.m_re * a.m_re + a.m_im * a.m_im;
}

inline __host__ __device__ complex operator/(const complex &a, const complex &b) {
	float invabs2 = 1 / abs2(b);
	return complex((a.m_re * b.m_re + a.m_im * b.m_im) * abs2(b),
								 (a.m_im * b.m_re - b.m_im * a.m_re) * abs2(b));
}



#define CUDA_CHECK(call)                                                          \
    do {                                                                          \
        cudaError_t err = call;                                                   \
        if (err != cudaSuccess) {                                                 \
            fprintf(stderr, "CUDA error at %s:%d: %s\n", __FILE__, __LINE__,      \
                    cudaGetErrorString(err));                                     \
            exit(EXIT_FAILURE);                                                   \
        }                                                                         \
    } while (0)

#define CUBLAS_CHECK(call)                                                        \
    do {                                                                          \
        cublasStatus_t status = call;                                             \
        if (status != CUBLAS_STATUS_SUCCESS) {                                    \
            fprintf(stderr, "cuBLAS error at %s:%d: ", __FILE__, __LINE__);       \
            if (status == CUBLAS_STATUS_NOT_INITIALIZED) fprintf(stderr, "CUBLAS_STATUS_NOT_INITIALIZED\n"); \
            else if (status == CUBLAS_STATUS_ALLOC_FAILED) fprintf(stderr, "CUBLAS_STATUS_ALLOC_FAILED\n"); \
            else if (status == CUBLAS_STATUS_INVALID_VALUE) fprintf(stderr, "CUBLAS_STATUS_INVALID_VALUE\n"); \
            else if (status == CUBLAS_STATUS_ARCH_MISMATCH) fprintf(stderr, "CUBLAS_STATUS_ARCH_MISMATCH\n"); \
            else if (status == CUBLAS_STATUS_MAPPING_ERROR) fprintf(stderr, "CUBLAS_STATUS_MAPPING_ERROR\n"); \
            else if (status == CUBLAS_STATUS_EXECUTION_FAILED) fprintf(stderr, "CUBLAS_STATUS_EXECUTION_FAILED\n"); \
            else if (status == CUBLAS_STATUS_INTERNAL_ERROR) fprintf(stderr, "CUBLAS_STATUS_INTERNAL_ERROR\n"); \
            else if (status == CUBLAS_STATUS_NOT_SUPPORTED) fprintf(stderr, "CUBLAS_STATUS_NOT_SUPPORTED\n"); \
            else if (status == CUBLAS_STATUS_LICENSE_ERROR) fprintf(stderr, "CUBLAS_STATUS_LICENSE_ERROR\n"); \
            else fprintf(stderr, "Unknown cuBLAS error\n");                       \
            exit(EXIT_FAILURE);                                                   \
        }                                                                         \
    } while (0)

void fillOnes(float *vec, int n);
void fillOnes(int *vec, int n);
void fillRandomized(float *mat, int n);

void printMatrix(float *mat, int m, int n);